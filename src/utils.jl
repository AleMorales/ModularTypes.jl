# This is based on combinedef from MacroTools but only works with signature, not
# the full definition
"""
    splitsig(sig)
`splitsig` converts a method signature into a dictionary structure. """
function splitsig(sig::Expr)
  error_msg = "Not a method signature: $sig"
  fcall_nowhere, whereparams = MacroTools.gatherwheres(sig)
  @assert(MacroTools.@capture(fcall_nowhere, ((func_(args__; kwargs__)) |
                                   (func_(args__; kwargs__)::rtype_) |
                                   (func_(args__)) |
                                   (func_(args__)::rtype_))),
          error_msg)
  @assert(MacroTools.@capture(func, (fname_{params__} | fname_)), error_msg)
  di = Dict(:name=>fname, :args=>args,
            :kwargs=>(kwargs===nothing ? [] : kwargs))
  if rtype !== nothing; di[:rtype] = rtype end
  if whereparams !== nothing; di[:whereparams] = whereparams end
  if params !== nothing; di[:params] = params end
  di
end

# This is based on combinedef from MacroTools but only works with signature, not
# the full definition
"""
    combinesig(dict::Dict)
`combinesig` takes a dictionary as generated by `splitsig` and constructs a
new method signature. """
function combinesig(dict::Dict)
  wparams = get(dict, :whereparams, [])
  name = dict[:name]
  if isempty(wparams)
      :($name($(dict[:args]...); $(dict[:kwargs]...)))
  else
      :($name($(dict[:args]...); $(dict[:kwargs]...)) where {$(wparams...)})
  end
end


"""
    splitannotation(ex)
`splitannotation` takes an expression describing a type anotation and returns a
dict with the name of the variable being annotated, the type and its parameters (if any)
"""
function splitannotation(ex)
  ex isa Symbol && (return ex)
  ex.head != :(::) && error("Expression was not a type annotation")
  # Get name and type
  MacroTools.@capture(ex, name_::typ_)
  out = Dict(:name => name, :typ => Symbol(), :params => :())
  # Split type if it is "curly"
  if typ isa Expr && typ.head == :curly
    out[:typ] = typ.args[1]
    out[:params] = typ.args[2]
  else
    out[:typ] = typ
  end
  return out
end

# Deal with trait types that are not visible and required module prefixes
function cleantype(cleantyp)
    if cleantyp isa Expr && cleantyp.head == :.
        cleantyp = cleantyp.args[2] # No matter how many nesting modules this works
        if cleantyp isa Expr && cleantyp.head == :quote
          cleantyp = cleantyp.args[1]
        elseif cleantyp isa QuoteNode
          cleantyp = cleantyp.value
        end
    end
    if cleantyp isa Symbol
        return cleantyp
    else
        error("I could not parse correctly the trait type ", cleantyp)
    end
end
